Quasi-Monte Carlo (QMC) methods can sometimes speed up simple Monte Carlo (MC) calculations by orders of magnitude?  What makes them work so well?

MC methods use computer generated random numbers to generate various scenarios.  When computing financial risk, the scenarios may be possible financial market outcomes.  When assessing the resiliency of the power grid, the scenarios represent power demand and power grid failures under different future weather conditions.

If $Y$ is the quantity of interest, e.g., profit (or loss) one month from now, and $Y_1, \ldots, Y_n$ are its possible values under the possible scenarios generated by a stochastic model, then we can estimate the \emph{mean} or average quantity of interest from these computer generated data as follows
\[
\mu = \Ex(Y) \approx \frac 1n \bigl ( Y_1 + \cdots + Y_n \bigr) = \hmu_n.
\]
The sample mean based on $n$ scenarios approximates the true mean, which is based on an infinite number of scenarios.

Simple MC chooses $Y_1, \ldots, Y_n$ to be independent and identically distributed (IID).  Intuitively, this means that any $Y_i$ bears no relationship to any other $Y_k$, and all $Y_i$ come from the same probability distribution or scenario-generating model.

This is good, but we can do better.  By choosing $Y_1, \ldots, Y_n$ to be more representative of the infinite number of possible scenarios, we can make $\hmu$ a better estimate of the mean, $\mu$.

The model that generates $Y$ is often written as $Y= f(\vX)$, where $\vX$ is a uniformly distributed vector in the $d$-dimensional unit cube $[0,1]^d$.  If $Y_i = f(\vX_i)$ for IID $\vX_i$, then we have simple MC.  Figure \ref{fig:iid_pts} shows a picture of IID uniform  $\vX_1, \ldots, \vX_{64}$ in $2$ dimensions.  Because the points are IID, there are gaps and clusters.

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{WhyQ/iid_uniform_pts.png}
    \caption{64 IID standard uniform points in 2 dimensions.}
    \label{fig:iid_pts}
\end{figure}

Figure \ref{fig:lat_pts} gives an example of $\vX_1, \ldots, \vX_{64}$ used in QMC methods.  These points are called integration lattice points.  Note that they more evenly fill the square than the IID points in Figure \ref{fig:iid_pts}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{WhyQ/lattice_pts.png}
    \caption{64 shifted lattice points in 2 dimensions.}
    \label{fig:lat_pts}
\end{figure}

Because these QMC points  are more even, they can give $\hmu_n$ with an error of nearly $\Order(n^{-1})$.  In contrast, the error of simple MC $\hmu_n$ is typically $\Order(n^{-1/2})$.  That's the reason to add Q to MC.

QMCPy \cite{QMCPy2020a} is our open source Python library that implements QMC methods, including point generators, cubatures, and stopping criteria.  This blog introduces you to QMC and QMCPy.