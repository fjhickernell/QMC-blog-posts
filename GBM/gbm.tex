\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{booktabs} 
\usepackage{xcolor}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{microtype}
\usepackage{siunitx}
\sisetup{
    round-mode = places,
    round-precision = 3,
    output-decimal-marker = .
}
\usepackage{float}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{enumitem} % Added for itemize spacing control
\usepackage[most]{tcolorbox}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=red,urlcolor=blue]{hyperref}

\lstdefinestyle{Python}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{gray}\itshape,
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pfaster,
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
}

\title{Highly Efficient Geometric Brownian Motion Modeling with QMCPy}
\author{Larysa Matiukha, Aleksei Sorokin, and Sou-Cheng Choi}
\date{\today}

\begin{document}
\maketitle

\begin{tcolorbox}[title=Quick Start,colback=blue!1,colframe=blue!30!black,breakable]
Install the required Python packages:
%
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,frame=none,numbers=none]
    pip install qmcpy numpy matplotlib
\end{lstlisting}

Minimal example to simulate 16 geometric Brownian motion paths over $\lbrack 0,1\rbrack$ with QMCPy's lattice sampler ($S_0=1$, $\mu=0.05$, $\sigma^2=0.2$) and plots five of them:
%
\lstinputlisting[
    style=Python,
    frame=none,
    numbers=none,
    label={lst:quickstart}
]{code/quickstart.py}
\end{tcolorbox}


\section{Introduction}

In this blog, we demonstrate how to simulate and analyze a geometric Brownian motion (GBM) process using QMCPy in Python.
GBM is widely used in finance to model stock prices and other assets. 
We will walk through key code snippets, plots, and insights. The numerical results can be reproduced using the Jupyter notebook available at \href{gbm\_demo.ipynb}{\url{https://github.com/QMCSoftware/QMCSoftware/blob/master/demos/gbm\_demo.ipynb}}.

GBM is a continuous stochastic process in which the natural logarithm of its values follows a Brownian motion (BM) $[1]$.
Mathematically, it can be defined as follows:
\begin{equation}
S_t = S_0 \, e^{\bigl(\mu - \tfrac{\sigma^2}{2}\bigr)  t + \sigma W_t}, \label{gbm}
\end{equation}
where
\begin{itemize}
\item $S_0$ is the initial value, 
\item $\mu$ is a drift coefficient
\item $\sigma^2$ is a diffusion coefficient ($\sigma$ is volatility)
\item $W_t$ is a (standard) BM.
\end{itemize}

At any time $0 < t \le T$, where $0$ and $T$ represent the beginning and end time of the process, $S_t$ follows a log-normal distribution with expected value and variance as follows (see Section 3.2 in $[1]$):
\begin{itemize}
\item
 $E[S_t] = S_0 e^{\mu t}$
\item $\text{Var}[S_t] = S_0^2 e^{2\mu t}(e^{\sigma^2 t} - 1)$
\item   $  
    \text{Cov}(S_{t_i}, S_{t_j}) = S_0^2 e^{\mu(t_i + t_j)} \left(e^{\sigma^2 \min(t_i, t_j)} - 1\right).$
\end{itemize}

GBM is commonly used to model stock prices driving option payoffs in derivatives pricing $[4, 5]$. 

\section{GBM Objects in QMCPy}

GBM in QMCPy inherits from BrownianMotion class $[2, 3]$. 
We can create a simple GBM instance and generate sample paths to see the class in action; see Listing~\ref{lst:gbm_qmcpy2}:

\lstinputlisting[
    style=Python,
    caption={Generating 4 GBM sample paths evaluated at 2 time points using QMCPy.},
    label={lst:gbm_qmcpy2}
]{code/gbm_qmcpy.py}

The output shows 4 sample paths evaluated at 2 time points, yielding a $(4 \times 2)$ array where rows represent paths and columns represent time steps:
\[
\left[
\begin{array}{@{} S[table-format=1.3] S[table-format=1.3] @{}}
\num{0.60712598} & \num{1.63922882} \\
\num{0.52555107} & \num{0.29133149} \\
\num{3.84628308} & \num{4.03575649} \\
\num{0.62311813} & \num{0.65946838}
\end{array}
\right].
\]

To validate theoretical properties, we generate $2^{12} = 4096$ paths over 5 time steps and compare empirical moments with theoretical values.  Note that the theoretical values match the last values captured in \texttt{qp\_gbm.mean\_gbm} and \texttt{qp\_gbm.covariance\_gbm} for the final time point. The results are shown in Table~\ref{tab1}.

\lstinputlisting[
    style=Python,
    caption={Generating and validating GBM sample moments.},
    label={lst:gbm-validation}
]{code/gbm_moments_validation.py} 

\begin{table}[tbp]
\centering
\caption{Theoretical vs Empirical Validation of GBM Properties.}
\begin{tabular}{ll}
\hline
\textbf{Statistic} & \textbf{Value} \\
\hline
Sample Mean & 105.127 (Theoretical: 105.127) \\
Sample Variance & 449.776 (Theoretical: 451.029) \\
\hline
Time Vector & [0.2,\; 0.4,\; 0.6,\; 0.8,\; 1.0] \\
Drift ($\mu$) & 0.05 \\
Diffusion ($\sigma^2$) & 0.040\\
Mean  & [101.005,\; 102.020,\; 103.045,\; 104.081,\; 105.127] \\
Decomposition Type & PCA \\
\hline
Covariance Matrix & 
\(
\left[\begin{array}{rrrrr}
81.943 &  82.767 &  83.599 &  84.439 &  85.288 \\
82.767 & 167.869 & 169.556 & 171.260 & 172.981 \\
83.599 & 169.556 & 257.923 & 260.516 & 263.134 \\
84.439 & 171.260 & 260.516 & 352.258 & 355.798 \\
85.288 & 172.981 & 263.134 & 355.798 & 451.029
\end{array}\right]
\)
\\
\hline
\end{tabular}
\label{tab1}
\end{table}

\section{GBM vs BM}

Below we compare BM and GBM using the same parameters: $\texttt{drift} = 0$, $\texttt{diffusion} = 1$, $\texttt{initial\_value} = 1$.
The driftless BM paths should fluctuate symmetrically around the initial value ($y = 1$) and can take negative values, while those of the GBM remain strictly positive. We generate these samples in Listing~\ref{lst:gbm_qmcpy3}.

\lstinputlisting[
    style=Python,
    caption={Generate 16 BM and 16 GBM sample paths.},
    label={lst:gbm_qmcpy3}
]{code/bm_gbm_16.py}

Next, we demonstrate how easily one can swap samplers or change parameters in QMCPy.  For example, to model a stock price
with initial value $S_0=50$, drift $\mu=0.1$, and volatility $\sigma=\sqrt{0.2}$ over a 5‐year horizon using IID sampling; see Listing~\ref{lst:gbm_iid_32}.

\lstinputlisting[
    style=Python,
    caption={Generate 32 GBM sample paths with IID sampling.},
    label={lst:gbm_iid_32}
]{code/gbm_iid_32.py}

Or, to use a low‐discrepancy lattice sampler with the same parameters (Listing~\ref{lst:gbm_lattice_32}):
\lstinputlisting[
    style=Python,
    caption={Generate 32 GBM sample paths with lattice sampling.},
    label={lst:gbm_lattice_32}
]{code/gbm_lattice_32.py}

%Now, let's define a utility function that will help us visualize BM or GBM paths with different samplers and parameters (Listing~\ref{lst:plot-paths}). 
The generated sample paths are plotted in Figure~\ref{fig:bm_gbm_paths}. Subplots~(\subref{fig:bm_iid}), (\subref{fig:gbm_iid}), (\subref{fig:bm_lattice}), and (\subref{fig:gbm_lattice}) show, respectively: 

\begin{itemize}
    \item BM with lattice sampler ($T=1$, $S_0=1$, $\mu=0$, $\sigma^2=1$, 16 paths)
    \item GBM with lattice sampler ($T=1$, $S_0=1$, $\mu=0$, $\sigma^2=1$, 16 paths)
    \item GBM with IID sampler ($T=5$, $S_0=50$, $\mu=0.1$, $\sigma^2=0.2$, 32 paths)
    \item GBM with lattice sampler ($T=5$, $S_0=50$, $\mu=0.1$, $\sigma^2=0.2$, 32 paths).
\end{itemize}

\begin{comment}
\lstinputlisting[
    style=Python,
    caption={Function to plot BM and GBM sample paths.},
    label={lst:plot-paths}
]{code/plot_paths.py}
\end{comment}

\begin{figure}[tbp]
\centering
\begin{subfigure}[t]{0.49\textwidth}
\centering
\includegraphics[width=\textwidth]{images/figure_1.png}
\caption{}
\label{fig:bm_iid}
\end{subfigure}
\begin{subfigure}[t]{0.49\textwidth}
\centering
\includegraphics[width=\textwidth]{images/figure_2.png}
\caption{}
\label{fig:gbm_iid}
\end{subfigure}
\begin{subfigure}[b]{0.49\textwidth}
\includegraphics[width=\textwidth]{images/figure_3.png}
\caption{}
\label{fig:bm_lattice}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.49\textwidth}
\includegraphics[width=\textwidth]{images/figure_4.png}
\caption{}
\label{fig:gbm_lattice}
\end{subfigure}
\caption{Comparison of sample paths for BM and GBM using different samplers.}
\label{fig:bm_gbm_paths}
\end{figure}

\section{QuantLib vs QMCPy Comparison}

In this section, we compare QMCPy's GeometricBrownianMotion implementation with the industry-standard QuantLib library [6] to validate its accuracy and performance. %We use Listing~\ref{lst:quantlib} to generate the QuantLib paths.
The numerical results are summarized in Table~\ref{tab2}. 

Both libraries produce statistically equivalent GBM simulations that match theoretical values. QMCPy typically runs 1.5 to 3 times faster due to vectorized operations, making it excellent for research and high-performance applications. QuantLib remains the industry standard for production systems that require comprehensive support for financial modeling and risk management.

\begin{comment}
\lstinputlisting[
    style=Python,
    caption={Function to generate GBM paths with QuantLib.},
    label={lst:quantlib}
]{code/quantlib.py}
\end{comment}

\begin{table}[btp]
\centering
\caption{QuantLib vs QMCPy: QMCPy is 1.8 times faster than QuantLib in generating thousands of paths.}
\begin{tabular}{lccc}
\toprule
\textbf{Method} & \textbf{Mean} & \textbf{Std. Dev.} & \textbf{Time (s)}   \\
\midrule
QuantLib & 105.29 & 21.16 & 0.898  \\
QMCPy & 105.13 & 21.23 & 0.496  \\
Theoretical & 105.13 & 21.24 & ---  \\
\bottomrule
\end{tabular}
\label{tab2}
\end{table}

 In Figure~\ref{fig:qmcpy_quantlib_comparison}, the top row shows sample paths: QMCPy on the left and QuantLib on the right. The bottom-left panel overlays the marginal distribution at $t=1$ (e.g., histograms or KDEs), where both libraries yield nearly identical shapes with means and standard deviations matching Table~\ref{tab2}. The bottom-right panel is a QMCPy covariance heatmap with time 0 at the top of the $y$-axis; the variance increases along the diagonal with time and the off-diagonal structure follows $\min(t_i,t_j)$, consistent with the analytic form and the numerical matrix in Table~\ref{tab1}.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{images/figure_5.png}
\caption{QMCPy vs QuantLib comparison. Top: sample paths from QMCPy (left) and QuantLib (right). Bottom left: marginal distribution at $t=1$ showing close agreement between libraries and with Table~\ref{tab2}. Bottom right: QMCPy covariance heatmap (time 0 at top), consistent with the numerical matrix in Table~\ref{tab1}.}
\label{fig:qmcpy_quantlib_comparison}
\end{figure}


\section{Internals}

The \texttt{GeometricBrownianMotion} class in QMCPy is engineered for speed, robustness, and mathematical correctness. Its design leverages object-oriented inheritance and vectorized operations, resulting in both flexibility and high performance.
\texttt{GeometricBrownianMotion} inherits from \texttt{BrownianMotion} which itself inherits from \texttt{Gaussian}. This layered design allows the GBM class to reuse and extend efficient implementations for Gaussian random vectors and BM increments.
The constructor rigorously checks input parameters (e.g., positivity of initial value and diffusion, valid decomposition type), ensuring mathematical integrity and preventing run-time errors.

The class uses vectorized NumPy operations to generate entire arrays of GBM paths in a single call, minimizing Python loops and maximizing computational throughput. Sample generation proceeds in two stages:
\begin{enumerate}
\item 
The parent class \texttt{BrownianMotion} generates standard BM sample paths using the specified sampler (e.g., low-discrepancy lattice, IID uniform), with drift and diffusion handled in the mean and covariance structure.
\item  The GBM class transforms the BM samples via the exponential mapping \eqref{gbm}, performed in a fully vectorized fashion, ensuring that thousands of paths can be efficiently simulated.
\end{enumerate}
The class computes and stores the theoretical mean and covariance matrices for GBM at initialization, which can be used for validation and theoretical comparisons. Both mean and covariance are calculated using analytical formulas, leveraging \href{https://numpy.org/devdocs/user/basics.broadcasting.html}{NumPy’s broadcasting} for efficient computations. (Briefly, broadcasting in NumPy allows arithmetic operations between arrays of different shapes by automatically expanding the smaller array to match the shape of the larger array.)

 The Gaussian and BM classes both implement Cholesky and PCA factorization of the covariance matrix
\[
\Sigma \;=\; L\,L^{\!\top}
\quad\text{and}\quad
\Sigma \;=\; P\,D\,P^{\!\top},
\]
respectively.  In the Cholesky method, one computes the lower‐triangular $L=\operatorname{chol}(\Sigma)$ and obtains correlated increments via $X=L\,Z$, where $Z\sim\mathcal{N}(0,I)$.  In the PCA approach, one first diagonalizes $\Sigma=PDP^{\!\top}$, then forms $X = P\,D^{1/2}\,Z$.  By default PCA is used for its superior numerical stability in high dimensions and slightly lower cost when many eigenvalues are near zero.  These correlated normals feed directly into the GBM update
\[
S_{t+\Delta t} \;=\; S_t\,\exp\!\Bigl((\mu - \tfrac12\sigma^2)\Delta t \;+\;\sigma\sqrt{\Delta t}\,X\Bigr),
\]
ensuring that the simulated paths respect the intended covariance structure and remain strictly positive (with strict‐positivity checks raising warnings or errors if violated).

\bigskip
\begin{tcolorbox}[title=Takeaways,colback=blue!1,colframe=blue!30!black]
\begin{itemize}[topsep=0pt,itemsep=0pt,parsep=0pt,leftmargin=*]
    \item Accuracy parity: QMCPy's GBM matches QuantLib's results and the theoretical moments (see Table~\ref{tab2}).
    \item Speed: Vectorized operations typically deliver 1.5--3$\times$ faster path generation in QMCPy for thousands of paths.
    \item Flexibility: Swap samplers (e.g., IID, lattice) or covariance decompositions (e.g., PCA, Cholesky) with a single argument change.
\end{itemize}
\end{tcolorbox}


\begin{thebibliography}{6}

\bibitem[1]{glasserman2003}
Glasserman, P. (2003). \textit{Monte Carlo Methods in Financial Engineering}. Springer.

\bibitem[2]{choi2022}
Choi, S.-C. T., Hickernell, F. J., Jagadeeswaran, R., McCourt, M. J., \& Sorokin, A. G. (2022).
Quasi-Monte Carlo Software. In A. Keller (Ed.), \textit{Monte Carlo and Quasi-Monte Carlo Methods}.
Springer International Publishing. DOI: \url{https://doi.org/10.1007/978-3-030-98319-2_2}.

\bibitem[3]{qmcpy2023}
Choi, S.-C. T., Hickernell, F. J., Jagadeeswaran, R., McCourt, M. J., \& Sorokin, A. G. (2020--2025).
QMCPy: A quasi-Monte Carlo Python Library (Version 2).
DOI: \url{https://doi.org/10.5281/zenodo.16822646}. 
Retrieved from \url{https://www.qmcpy.org}.

\bibitem[4]{hull2017}
Hull, J. C. (2017). \textit{Options, Futures, and Other Derivatives} (10th ed.). Pearson.

\bibitem[5]{ross2014}
Ross, S. M. (2014). \textit{Introduction to Probability Models} (11th ed.). Academic Press.

\bibitem[6]{quantlib} 
The QuantLib contributors. (2003--2025). 
QuantLib: A free/open-source library for quantitative finance (Version 1.38).
DOI: \url{https://doi.org/10.5281/zenodo.1440997}. 
Retrieved from \url{https://www.quantlib.org}.
% https://github.com/lballabio/QuantLib/commit/87c5ee2e17e9dd17488ec9957159b89db18d5d26
\end{thebibliography}

\end{document}